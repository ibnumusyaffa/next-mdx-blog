---
date: 2022-05-28
category: General
category_color: blue
title: "Mengenal Big O notation dalam pemrograman"
description: "Pada artikel ini kita akan berkenalan dengan big O notation dan mempraktekanya dengan javascript"
thumbnail: blog/js.jpg
show_thumbnail: false
show_toc: false
is_published: false
---

Semua pemrogram pasti ingin semua kode yang ia tulis menghasilkan kode efisien, dari sini muncul pertanyaan, bagaimana kita menentukan mana kode yang efisien dan mana yang bukan ? nah untuk mengetahuinya kita bisa memakai konsep Big O notation.

## Jadi apa itu Big O notation ?

Big O notation adalah sebuah notasi matematis, untuk mengkomunikasikan seberapa efisien suatu algoritma bereaksi terhadapt input yang berikan atau jumlah data yang perlu diproses. Efisiensi dalam hal ini adalah efisiensi secara umum, karena bisa jadi 2 algoritma sekilas sama, tetapi ketika dibenchmark hasilnya cukup berbeda, hal bisa jadi karena beberapa kasus sudah dioptimasi otomatis oleh compiler/intrepeter dari bahasa yang kita pakai. efisien disini bisa dilihat dari 2 sisi

### Time Complexity

Yaitu berapa waktu yang dibutuhkan suatu algoritma untuk menyelesaikan suatu tugas.

### Space Complexity

Yaitu berapa memory yang dibutukan algoritma untuk menyelesaikan tugas. ada kalanya suatu algoritma lebih cepat dalam menyelesaikan suatu tugas, tetapi membutuhkan memory lebih banyak.

Dari 2 sisi diatas, ketika kita berbicara tentang big o notation, umumnya yang dibahas adalah tentang time complexity, maka dari itu mari kita bahas beberapa notasi big O melalui kacamata Time Complexity

### 1. O(1) - Constant time

Contoh function yang mempunya notation O(1)

```javascript
let data = [0, 2, 3, 4, 5, 7, 8];
function getFirstAndSecondData(data) {
  if (data.length < 2) {
    throw "not enough";
  }
  let first = data[0];
  let second = data[1];
  return {
    first,
    second,
  };
}

console.log(getFirstAndSecondData(data));
```

didalam function `getFirstAndSecondData()` kita bisa mengetahui secara umum diperlukan minimal 4 langkah untuk menjalankan algoritma didalam function tersebut atau bisa kita notasikan O(4). Function/algoritma ini akan tetap konstan berapapun jumlah input yang diberikan, apakah itu array berisi 10 data atau 100rb data, maka dari itu notasi O(4) bisa kita sederhakan menjadi O(1)

### 3. O(n) - Linear time

berikut contoh kodenya

```javascript
let data = ["dog", "bird", "rabbit", "cat"];

function findCat(data) {
  for (const item of data) {
    if (item === "cat") {
      return item;
    }
  }

  return null;
}
console.log(findCat(data));
```

pada function `findCat()` ini kita bisa mengasumsikan function ini akan mengeksekusi perintah didalamnya minimal 1 sampai dengan 4 kali (sesuai data yang diinput), jika data yang berisi "cat" ada diindex pertama maka cukup 1 kali eksekusi, jika "cat" berada diakhir data, maka akan dieksusi sebesar 4 kali. singkatnya notasinya bisa dari 0(1) sampai dengan O(4), nah dari sini perlu dipahami bahwa notasi big O akan selalu ditulis dalam bentuk worst case scenarionya yakni O(4) atau bisa ditulis O(n), kode yang dieksekusi akan bersifat liner terhadap jumlah data yang masukkan.

### 3. O(log n) — Logarithmic Time

```javascript
function binarySearch(data, x) {
  let start = 0;
  let end = data.length - 1;

  while (start <= end) {
    let middle = Math.floor((start + end) / 2);
    console.log(middle)
    if (data[middle] === x) {
      return true;
    } else if (data[middle] < x) {
      start = middle + 1;
    } else {
      end = middle - 1;
    }
  }

  return false;
}

let sortedData = [1, 2, 3, 4, 5, 6, 7, 8, 9];
console.log(binarySearch(sortedData, 1));
```
Salah satu contoh implementasi O(log n) dengan binary search, function `binarySearch()` akan memotong array menjadi 2 bagian disetiap iterasi perulangan dan hanya akan melanjutkan pencarian dibagian yang mempunyai chanche tertinggi, sehingga time complexitynya akan lebih cepat dari pada O(n) yang harus melakukan traversal melewati semua element array

### 4. O(n²) — Quadratic Time

```javascript
let data = [5, 4, 3, 2, 1, 10, 9, 8, 7, 6];

function bubbleSort(data) {
  let len = data.length;
  for (let i = 0; i < len; i++) {
    for (let j = 0; j < len; j++) {
      if (data[j] > data[j + 1]) {
        let tmp = data[j];
        data[j] = data[j + 1];
        data[j + 1] = tmp;
      }
    }
  }
  return data;
}
console.log(bubbleSort(data));
```

Operasi yang dibutuhkan untuk mensorting dengan bubbleSort untuk 10 element yaitu 100 langkah, atau n²

### 5. O(2^n) — Exponential Time

Salah santuh contoh ketika perlu membuat semua kombinasi dari suatu topping makanan, maka langkah yang perlu dilakukan akan meninggkat secara exponential sesuai jumlah topping yang ada.

0 toppings: 1 combination (no toppings at all)\
1 toppings: 2 combinations (none, a)\
2 toppings: 4 combinations (none, a, b, ab)\
3 toppings: 8 combinations (none, a, b, c, ab, ac, bc, abc)\
...\
...\
10 toppings: 1,024 combinations\
20 toppings: 1,048,576 combinations


## Penutup

